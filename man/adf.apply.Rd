% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/adf.apply.r
\name{adf.apply}
\alias{adf.apply}
\title{Apply a Function to an Abstract Data Frame}
\usage{
adf.apply(x, FUN, args = list(), outDir = NULL, type = c("data.frame",
  "model", "sparse.model"), formula = NULL, contrasts = NULL,
  subset = NULL, weights = NULL, na.action = NULL, offset = NULL,
  params = list())
}
\arguments{
\item{x}{an abstract data frame object}

\item{FUN}{function to apply over each chunk; its first argument must
accept the abstract data frame, and the second (optional)
argument accepts the args parameter}

\item{args}{Option list of arguments which are passed as a second
argument to FUN}

\item{outDir}{if ‘NULL’, the default, results are passed back to R;
otherwise this gives the output location (a new directory)
for storing the results}

\item{type}{type of data to give as an input to FUN. If model or sparse
model, this is a list giving the response (y), model matrix
(x), weights (w), and offset (offset) from the input forumal.}

\item{formula}{a formula to used with type equal to model or sparse.model}

\item{contrasts}{contrasts to used with type equal to model or sparse.model}

\item{subset}{a string to to used with type equal to model or sparse.model.
Will be evaluated in the environment of the data frame (ex.
subset = "V2 + V3 > V4")}

\item{weights}{a string to to used with type equal to model or sparse.model.
Will be evaluated in the environment of the data frame.}

\item{na.action}{a function which indicates what should happen when the data
contain 'NA's. See lm.fit for more details.}

\item{offset}{a string to to used with type equal to model or sparse.model.
Will be evaluated in the environment of the data frame.}

\item{params}{a named list of additional parameters that depends on the
type of abstract data frame that was created}
}
\description{
Low level function for applying over an abstract data frame.
}
\examples{
n <- 100
test_df <- data.frame(col1 = sample(state.abb,n,TRUE),
                      col2 = sample(1:10,n,TRUE),
                      col3 = runif(n),
                      col4 = complex(n,runif(n),runif(n)),
                      stringsAsFactors = FALSE)
write.table(test_df, tf <- tempfile(), sep = "|",
            quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(test_df, tf2 <- tempfile(), sep = "|",
            quote = FALSE, row.names = FALSE, col.names = FALSE)

adfObj <- adf(c(tf,tf2))
adfObj <- allFactorLevels(adfObj)

# Construct OLS beta hat
adfObj <- adf(c(tf,tf2))
calcOLSmats <- function(u) list(XtX = t(u$x) \%*\% u$x, Xty = t(u$x) \%*\% u$y)
v <- adf.apply(adfObj, formula = "V3 ~ V2 + V1", calcOLSmats , 
               type = "model")
XtX <- Reduce(`+`, Map(getElement, v, "XtX"))
Xty <- Reduce(`+`, Map(getElement, v, "Xty"))

test_df2 <- rbind(test_df)
betaDF <- coef(lm(col3 ~ col2 + col1, data = test_df2))
betaADF <- qr.solve(XtX, Xty)
err <- max(abs(betaDF - betaADF))
err

unlink(tf)
unlink(tf2)
}

